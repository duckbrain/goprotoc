package plugins

import (
	"bytes"
	"reflect"
)

// TypeKind is an enumeration of the allowed categories of TypeNames.
type TypeKind int

const (
	// The type is a named type. The only information available in the TypeName
	// is the package and name of the type, not its underlying type. The type's
	// Symbol() method can be used to get the details of the name.
	KindNamed TypeKind = iota
	// The type is an unnamed basic type (i.e. primitive). The type's
	// BasicKind() method can be used to determine which basic type it is.
	KindBasic
	// The type is a pointer. The type's Elem() method can be used to determine
	// the type to which it points.
	KindPtr
	// The type is a slice. The type's Elem() method can be used to determine
	// the slice's element type.
	KindSlice
	// The type is a map. The type's Key() and Elem() methods can be used to
	// determine the map's key and value types, respectively.
	KindMap
)

// TypeName represents a Go type, nominally. It is suitable for rendering a type
// use in source, but not for defining a type. It is meant to represent only the
// kinds of types generated by a protoc plugin. As such, it can represent neither
// channel types nor unnamed struct or interface types.
type TypeName struct {
	kind  TypeKind
	elem  *TypeName
	key   *TypeName
	sym   *Symbol
	basic reflect.Kind
}

var (
	typeBool   = &TypeName{kind: KindBasic, basic: reflect.Bool}
	typeString = &TypeName{kind: KindBasic, basic: reflect.String}
	typeBytes  = &TypeName{
		kind: KindSlice,
		elem: &TypeName{kind: KindBasic, basic: reflect.Uint8},
	}
	typeInt32   = &TypeName{kind: KindBasic, basic: reflect.Int32}
	typeInt64   = &TypeName{kind: KindBasic, basic: reflect.Int64}
	typeUint32  = &TypeName{kind: KindBasic, basic: reflect.Uint32}
	typeUint64  = &TypeName{kind: KindBasic, basic: reflect.Uint64}
	typeFloat32 = &TypeName{kind: KindBasic, basic: reflect.Float32}
	typeFloat64 = &TypeName{kind: KindBasic, basic: reflect.Float64}
)

// Kind returns the kind of this type, which determines which other method(s)
// can be invoked to extract more details on what Go type this represents.
func (tn *TypeName) Kind() TypeKind {
	return tn.kind
}

// Elem returns the underlying or element type. For slices, it's the element
// type; for pointers, it's the pointed-at type; and for maps, it's the value
// type. Returns nil if this type is not a pointer, slice, or map.
func (tn *TypeName) Elem() *TypeName {
	return tn.elem
}

// Key returns the key type for a map. Returns nil if this type is not a map.
func (tn *TypeName) Key() *TypeName {
	return tn.key
}

// Symbol returns the type element's name for a named type. Returns nil if this
// is not a named type.
func (tn *TypeName) Symbol() *Symbol {
	return tn.sym
}

// BasicKind returns the kind of basic/primitive type. Returns reflect.Invalid
// if this is not a basic type.
func (tn *TypeName) BasicKind() reflect.Kind {
	return tn.basic
}

func ptrType(t *TypeName) *TypeName {
	return &TypeName{kind: KindPtr, elem: t}
}

func sliceType(t *TypeName) *TypeName {
	return &TypeName{kind: KindSlice, elem: t}
}

func mapType(k, v *TypeName) *TypeName {
	return &TypeName{kind: KindMap, key: k, elem: v}
}

func namedType(sym *Symbol) *TypeName {
	return &TypeName{kind: KindNamed, sym: sym}
}

// String returns a representation of this type that is suitable for rendering
// into Go source.
func (tn *TypeName) String() string {
	switch tn.Kind() {
	case KindBasic:
		if tn.BasicKind() == reflect.Uint8 {
			return "byte"
		} else {
			return tn.BasicKind().String()
		}
	case KindNamed:
		return tn.Symbol().String()
	default:
		var buf bytes.Buffer
		tn.toString(&buf)
		return buf.String()
	}
}

func (tn *TypeName) toString(b *bytes.Buffer) {
	switch tn.Kind() {
	case KindBasic:
		if tn.BasicKind() == reflect.Uint8 {
			b.WriteString("byte")
		} else {
			b.WriteString(tn.BasicKind().String())
		}
	case KindNamed:
		sym := tn.Symbol()
		if sym.Package.Name != "" {
			b.WriteString(sym.Package.Name)
			b.WriteRune('.')
		}
		b.WriteString(sym.Name)
	case KindMap:
		b.WriteString("map[")
		tn.Key().toString(b)
		b.WriteRune(']')
		tn.Elem().toString(b)
	case KindSlice:
		b.WriteString("[]")
		tn.Elem().toString(b)
	case KindPtr:
		b.WriteRune('*')
		tn.Elem().toString(b)
	}
}
